(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5677],{3905:function(e,n,t){"use strict";t.r(n),t.d(n,{MDXContext:function(){return c},MDXProvider:function(){return p},mdx:function(){return y},useMDXComponents:function(){return s},withMDXComponents:function(){return u}});var r=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){return function(n){var t=s(n.components);return r.createElement(e,o({},n,{components:t}))}},s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),u=s(t),p=a,f=u["".concat(i,".").concat(p)]||u[p]||m[p]||o;return t?r.createElement(f,l(l({ref:n},c),{},{components:t})):r.createElement(f,l({ref:n},c))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=f;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},32850:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var r=t(22122),a=t(19756),o=(t(2784),t(3905)),i={id:"delay-render",title:"delayRender() and continueRender()",sidebar_label:"delayRender()"},l={unversionedId:"delay-render",id:"delay-render",isDocsHomePage:!1,title:"delayRender() and continueRender()",description:"By calling delayRender, you are signaling that a frame should not be immediately rendered and instead should wait on an asynchronous task to complete.",source:"@site/docs/delay-render.md",sourceDirName:".",slug:"/delay-render",permalink:"/docs/delay-render",editUrl:"https://github.com/JonnyBurger/remotion/edit/main/packages/docs/docs/delay-render.md",version:"current",sidebar_label:"delayRender()",frontMatter:{id:"delay-render",title:"delayRender() and continueRender()",sidebar_label:"delayRender()"},sidebar:"someSidebar",previous:{title:"continueRender()",permalink:"/docs/continue-render"},next:{title:"interpolate()",permalink:"/docs/interpolate"}},d=[{value:"Useful to know",id:"useful-to-know",children:[]},{value:"Example",id:"example",children:[]},{value:"See also",id:"see-also",children:[]}],c={toc:d};function u(e){var n=e.components,t=(0,a.default)(e,["components"]);return(0,o.mdx)("wrapper",(0,r.default)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"By calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"delayRender"),", you are signaling that a frame should not be immediately rendered and instead should wait on an asynchronous task to complete."),(0,o.mdx)("p",null,"This method is useful if you for example want to call an API to fetch data before you before you render."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"delayRender")," returns an identifier. Once you have fetched data or finished the asynchronous task, you should call ",(0,o.mdx)("inlineCode",{parentName:"p"},"continueRender(identifier)")," to let Remotion know that you are now ready to render."),(0,o.mdx)("h2",{id:"useful-to-know"},"Useful to know"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"You need to call ",(0,o.mdx)("inlineCode",{parentName:"p"},"continueRender()")," within 30 seconds of page load. This is the default timeout of puppeteer and it will throw if you miss to call ",(0,o.mdx)("inlineCode",{parentName:"p"},"continueRender()"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"For every frame that is rendered, the whole page is reloaded, so the whole lifecycle of ",(0,o.mdx)("inlineCode",{parentName:"p"},"delayRender")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"continueRender")," happens on every frame. If you are doing an API request, you can speed up the render and avoid rate limits by caching the request, for example by storing the data in ",(0,o.mdx)("inlineCode",{parentName:"p"},"localStorage"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"You can call ",(0,o.mdx)("inlineCode",{parentName:"p"},"delayRender")," multiple times. The render will be blocked for as long as at least one blocking handle exists and that has not been cleared by ",(0,o.mdx)("inlineCode",{parentName:"p"},"continueRender()"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"You should put ",(0,o.mdx)("inlineCode",{parentName:"p"},"delayRender()")," calls inside your components rather than placing them as a top-level statement, to avoid blocking a render if a different composition is rendered. Also, in the example below the call is wrapped in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"useState()")," to avoid creating multiple blocking calls when the component rerenders."))),(0,o.mdx)("h2",{id:"example"},"Example"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"import {useEffect, useState} from 'react';\nimport {continueRender, delayRender} from 'remotion';\n\nexport const MyVideo = () => {\n  const [data, setData] = useState(null);\n  const [handle] = useState(() => delayRender());\n\n  const fetchData = async () => {\n    const response = await fetch('http://example.com/api');\n    const json = await response.json();\n    setData(json);\n\n    continueRender(handle);\n  }\n\n  useEffect(() => {\n    fetchData();\n  },\xa0[]);\n\n  return (\n    <div>\n      {data ? (\n        <div>This video has data from an API! {JSON.stringify(data)}</div>\n      ) : null}\n    </div>\n  );\n}\n\n")),(0,o.mdx)("h2",{id:"see-also"},"See also"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/data-fetching"},"Data fetching"))))}u.isMDXComponent=!0}}]);